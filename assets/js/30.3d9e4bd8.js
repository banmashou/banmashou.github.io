(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{504:function(t,a,s){"use strict";s.r(a);var r=s(13),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"javascript-的数据类型都有什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的数据类型都有什么"}},[t._v("#")]),t._v(" JavaScript 的数据类型都有什么")]),t._v(" "),a("p",[t._v("基本数据类型：String,Boolean,number,undefined,object,Null"),a("br"),t._v("\n引用数据类型：Object(Array,Date,RegExp,Function)")]),t._v(" "),a("h2",{attrs:{id:"js中-null-和-undefined-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js中-null-和-undefined-的区别"}},[t._v("#")]),t._v(" JS中 null 和 undefined 的区别")]),t._v(" "),a("p",[t._v("相同点：隐式类型转换都是false"),a("br"),t._v("\n不同点：number(null) 是0，number(undefined)是NaN\nnull表示值被定义了，但是空值 undefined表示未被定义")]),t._v(" "),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("闭包说的通俗一点就是打通了一条在函数外部访问函数内部作用域的通道。正常情况下函数外部是访问不到函数内部作用域变量的，\n判断是不是闭包:函数嵌套函数,内部函数被return  内部函数调用外层函数的局部变量")]),t._v(" "),a("ul",[a("li",[t._v("优点：可以隔离作用域，不造成全局污染")]),t._v(" "),a("li",[t._v("缺点：由于闭包长期驻留内存，则长期这样会导致内存泄露")]),t._v(" "),a("li",[t._v("如何解决内存泄露：将暴露全外部的闭包变量置为null、不用闭包")])]),t._v(" "),a("h2",{attrs:{id:"事件委托是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件委托是什么"}},[t._v("#")]),t._v(" 事件委托是什么")]),t._v(" "),a("p",[t._v("事件委托就是利用事件冒泡，只定制一个事件处理程序，就可以管理某一类型的所有事件。"),a("br"),t._v("\n事件委托，称为事件代理，是JS中很常用的绑定事件的方法。事件委托就是把原本需要绑定在子元素上面的事件委托给父元素，让父元素担当事件监听的职务，原理是DOM元素的事件冒泡。")]),t._v(" "),a("h2",{attrs:{id:"什么是事件冒泡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是事件冒泡"}},[t._v("#")]),t._v(" 什么是事件冒泡")]),t._v(" "),a("p",[t._v("一个事件触发后，会在子元素和父元素之间传播，这种传播分为三个阶段："),a("br"),t._v("\n捕获阶段（从 window 对象传导到目标节点（从外到里），这个阶段不会响应任何事件）"),a("br"),t._v("\n目标阶段（在目标节点上触发）"),a("br"),t._v("\n冒泡阶段（从目标节点传导回window对象，从里到外。） 事件委托/事件代理就是利用事件冒泡的机制把里层需要响应的事件绑定到外层")]),t._v(" "),a("h2",{attrs:{id:"javascript本地存储的方式有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript本地存储的方式有哪些"}},[t._v("#")]),t._v(" Javascript本地存储的方式有哪些")]),t._v(" "),a("p",[a("strong",[t._v("相同点：")]),t._v("\n都是在浏览器（客户端）内存储，存储方式为字符串"),a("br"),t._v(" "),a("strong",[t._v("不同点：")]),t._v("\n生命周期："),a("br")]),t._v(" "),a("ul",[a("li",[t._v("cookie如果不设置有效期，就是临时存储（存储在内存中），如果设置了有效期，到期之后会消失（存储在硬盘里）"),a("br")]),t._v(" "),a("li",[t._v("localStorage是永久存储，关闭浏览器数据也不会消失，除非手动删除"),a("br")]),t._v(" "),a("li",[t._v("sessionStorage是临时存储，仅在当前回话下有效。引入了一个窗口的概念，数据仅在当前窗口下生效，关闭当前窗口的话数据会被删除"),a("br")]),t._v(" "),a("li",[t._v("cookie数据在每次网络请求的时候都会被发送给服务端，localStorage和sessionStorage则不会"),a("br")]),t._v(" "),a("li",[t._v("cookie大小限制为4kb，storage则为5M"),a("br")]),t._v(" "),a("li",[t._v("storage比cookie的安全性更高一些")])]),t._v(" "),a("h2",{attrs:{id:"let、const和var的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let、const和var的区别"}},[t._v("#")]),t._v(" let、const和var的区别")]),t._v(" "),a("ul",[a("li",[t._v("var声明的变量会挂载在window上，而let和const则不会")]),t._v(" "),a("li",[t._v("var声明的变量存在变量提升，而let和const则不会")]),t._v(" "),a("li",[t._v("同一个作用域下var可以声明同名变量，而let和const则不行")]),t._v(" "),a("li",[t._v("let和const会生成块级作用域")]),t._v(" "),a("li",[t._v("const一旦声明之后不可修改，如果是复杂数据类型的话，可以修改其属性")])]),t._v(" "),a("h2",{attrs:{id:"普通函数与构造函数的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通函数与构造函数的区别"}},[t._v("#")]),t._v(" 普通函数与构造函数的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 构造函数也是一个普通函数，创建方式和普通函数一致，但是构造函数习惯性首字母大写\n2. 调用方式不一样，普通函数直接调用，构造函数要用new去实例化\n3. 调用时，构造函数内部会创建一个新对象，普通函数不会创建新对象\n4. 构造函数内部的this指向实例，普通函数内部的this指向调用函数的对象，如果没有调用对象，则默认为window\n5. 构造函数默认的返回值是创建的对象，普通函数的返回值由内部的return决定\n6. 构造函数的函数名与类名相同\n")])])]),a("h2",{attrs:{id:"js中什么是原型和原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js中什么是原型和原型链"}},[t._v("#")]),t._v(" JS中什么是原型和原型链")]),t._v(" "),a("p",[a("strong",[t._v("原型关系：")]),a("br"),t._v("\n每个 class 都有显示原型 prototype"),a("br"),t._v("\n每个实例都有隐式原型 _ proto_"),a("br"),t._v("\n实例的_ proto_指向对应 class 的 prototype")]),t._v(" "),a("p",[a("strong",[t._v("原型：")]),a("br"),t._v("\n在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一\n些预定义的属性。其中每个函数对象都有一个 prototype 属性，这个属性指向函\n数的原型对象。")]),t._v(" "),a("p",[a("strong",[t._v("原型链：")]),a("br"),t._v("\n函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原\n型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层\n的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一\n直指向 Object 的原型对象上，而 Object 原型对象用 Object.prototype.__ proto__ = null 表示原型链顶端。如此形成了 js 的原型链继承")]),t._v(" "),a("h2",{attrs:{id:"防抖和节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防抖和节流"}},[t._v("#")]),t._v(" 防抖和节流")]),t._v(" "),a("p",[a("strong",[t._v("函数防抖：")]),a("br"),t._v("\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时。也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。")]),t._v(" "),a("p",[a("strong",[t._v("函数节流：")]),a("br"),t._v("\n当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次\n用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行")]),t._v(" "),a("h2",{attrs:{id:"字符串、数组-有哪些方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串、数组-有哪些方法"}},[t._v("#")]),t._v(" 字符串、数组 有哪些方法")]),t._v(" "),a("p",[a("strong",[t._v("数组方法：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. eshift 删除数组中的第一个元素\n2. pop 删除数组中的最后一个元素\n3. unshift 增加元素在数组的前面\n4. push 增加元素在数组的后面\n5. map 循环，并且返回新的数组\n6. forEach 循环，遍历\n7. filter 过滤，筛选出数组中的满足条件的，并且返回新的数组\n8. concat 合并数组\n")])])]),a("p",[a("strong",[t._v("字符串方法：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. slice() 提取字符串的片段，并在新的字符串中返回被提取的部分\n2. split() 把字符串分割为字符串数组\n3. replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n4. substr() 从起始索引提取字符串中指定数目的字符\n5. substring() 提取字符串中两个指定索引之间的字符\n6. indexOf() 返回某个指定的字符串值在字符串中首次出现的位置\n7. includes() 查找字符串中是否包含指定的字符串\n")])])]),a("h2",{attrs:{id:"什么是深拷贝、浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是深拷贝、浅拷贝"}},[t._v("#")]),t._v(" 什么是深拷贝、浅拷贝")]),t._v(" "),a("p",[a("strong",[t._v("浅拷贝：")]),t._v("\n如果 是基本类型，拷贝的就是基本类型的值；如果 是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了，就会影响到另一个对象。")]),t._v(" "),a("p",[a("strong",[t._v("深拷贝：")]),t._v("\n在计算机中开辟一块新的内存地址，递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去一一赋值 ，相互不影响")]),t._v(" "),a("h2",{attrs:{id:"es6新增哪些特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6新增哪些特性"}},[t._v("#")]),t._v(" es6新增哪些特性")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 新增了块级作用域（let，const）\n2. 提供了定义类的语法糖（class）\n3. 新增了一种基本数据类型（Symbol）\n4. 新增了变量的解构赋值\n5. 函数参数允许设置默认值，引入了rest参数，新增了箭头函数。\n6. 数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。\n7. 对象和数组新增了扩展运算符\n8. S6新增了模块化（import / export）\n9. S6新增了Set和Map数据结构。\n10. ES6原生提供Proxy构造函数，用来生成Proxy实例\n11. ES6新增了生成器（Generator）和遍历器（Iterator）\n")])])]),a("h2",{attrs:{id:"箭头函数和普通函数区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数和普通函数区别"}},[t._v("#")]),t._v(" 箭头函数和普通函数区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n2. 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n3. 箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数替。\n4. 箭头函数不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n5. 箭头函数使用call()和apply()调用\n")])])]),a("h2",{attrs:{id:"什么是promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是promise"}},[t._v("#")]),t._v(" 什么是Promise")]),t._v(" "),a("p",[t._v("简单来说可以把promise当作一个装着异步操作结果的容器。从语法上说，Promise\n是一个对象，从它可以获取异步操作的消息。Promise 提供统一的\nAPI，各种异步操作都可以用同样的方法进行处理。它将异步函数以同步的方式书写，也解决了回调地狱问题")]),t._v(" "),a("h2",{attrs:{id:"http状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 1xx表示客户端应该继续发送请求\n2. 2xx表示成功的请求\n3. 200表示OK，正常返回信息\n4. 201表示请求成功且服务器创建了新的资源\n5. 202表示服务器已经接受了请求，但还未处理\n6. 3xx表示重定向\n7. 301表示永久重定向，请求的网页已经永久移动到新位置\n8. 302表示临时重定向\n9. 304表示自从上一次请求以来，页面的内容没有改变过\n10. 4xx表示客户端错误\n11. 401表示服务器无法理解请求的格式\n12. 402表示请求未授权\n13. 403表示禁止访问\n14. 404表示请求的资源不存在，一般是路径写错了\n15. 5xx表示服务器错误\n16. 500表示最常见的服务器错误\n17. 503表示服务器暂时无法处理请求，一段时间后可能恢复正常\n")])])]),a("h2",{attrs:{id:"new操作符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new操作符"}},[t._v("#")]),t._v(" new操作符")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 创建一个新的对象obj\n2. 将对象与构建函数通过原型链连接起来\n3. 将构建函数中的this绑定到新建的对象obj上\n4. 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);